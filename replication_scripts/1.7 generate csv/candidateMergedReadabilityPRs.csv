url,number_java_files,pr_title,pr_body,mergedAt,mergedBy,author,number_contributors,number_reviewers,commit_message,comments_message,reviewers_message
https://github.com/square/moshi/pull/1467,3,Convert AdapterMethodsFactory.java to kotlin,Ref #1252 ,2022-01-19 03:45:42,ZacSweers,spencergriffin,84,2,"Rename AdapterMethodsFactory from java to kt|Convert AdapterMethodsFactory.java to AdapterMethodsFactory.kt|Make kotlin more idiomatic|Use forEach loop|Spotless|More idiomatic kotlin|Inline toString|Address comments from PR|Address comments in PR review|Spotless|Use templated string for error message|Add japicmp exclusion for internal AdapterMethodsFacotry#get method|Convert if to when|Convert if to when|Use templated strings|Replace forEach with for loop|Simplify expression|Add local val to avoid cast|Update moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.kt  Co-authored-by: Zac Sweers  pandanomic@gmail.com>|Better variable names|Merge branch 'adaptermethodsfactory-kotlin' of github.com:spencergriffin/moshi into adaptermethodsfactory-kotlin|Exclude entire AdapterMethodsFactory class in japicmp|Update moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.kt  Co-authored-by: Zac Sweers  pandanomic@gmail.com>|Update moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.kt  Co-authored-by: Zac Sweers  pandanomic@gmail.com>|Update moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.kt  Co-authored-by: Zac Sweers  pandanomic@gmail.com>|Update moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.kt  Co-authored-by: Zac Sweers  pandanomic@gmail.com>|Import knownNotNull|Add requireNull in Util to create error message|Rename argument|Convert error message to raw string|Use generateSequence to iterate through the superclasses|Use it rather than complicated name|Rename requireNull to checkNull, and remove contract|Fix tests since error type changed|Update moshi/src/main/java/com/squareup/moshi/internal/Util.kt","Lets get #1468 done before proceeding with this or any other PRs, it's important we get expectations set for the resulting Kotlin code|Please link individual commit shas when addressing. Linking the diff is not useful/helpful for review|Also - big ""address CR comments"" commits like 3e6e9bd are unhelpful because then reviewers have to go manually check everywhere to see if you actually addressed it. Please do them in individual, targeted commits|Nice work!","Did an early pass but will need to look more. Please try to take a pass at cleaning up some of the style/syntax issues and use idiomatic APIs. It's very obvious right now that this was run through the autoconverter ||||||||||Sorry a lot of comments on this round. There are a lot of the same issues as your other PR, let's try to take a stronger pass at the converted code before settling on it for code review, this needs a lot of work ||||||||||||||||||||||||||||||||||||||||||||||||"
https://github.com/square/moshi/pull/1469,1,Convert ClassFactory.java to kotlin,"",2022-01-13 06:26:09,ZacSweers,spencergriffin,84,2,Rename ClassFactory from java to kt|Convert ClassFactory.java to ClassFactory.kt|Add missing unchecked cast suppressions|Spotless|Make kotlin more idiomatic|Fix invalid api after rebase|Remove operator from get function and rename unsafeField,,||||
https://github.com/square/moshi/pull/1460,6,Convert adapters to Kotlin,Ref #1252    Continuation from #1320 with CR comments addressed,2022-01-06 20:15:49,ZacSweers,ZacSweers,84,3,Convert Rfc3339DateJsonAdapter|Convert EnumJsonAdapter|Convert PolymorphicJsonAdapterFactory|Convert Rfc3339DateJsonAdapter and Iso8601Utils|Doc indent fix|Use template|Address CR comments|Spotless and jsr cleanup|Couple small tweaks|Merge branch 'master' into z/kotlinAdapters|Remove toList()|Use simpler map|Inline GregorianCalendar|Interp|Fix copyright|interp|Fix another copyright|Restore toList(),,||||||||
https://github.com/square/moshi/pull/1400,1,`JsonUtf8Reader` --> Kt,"(I'm aware that this PR will probably block on the work to upstream KSP into Moshi; I figured I'd just get this up while I had the time)    Attempting to follow the guidelines in #1252, I've converted `JsonUtf8Reader` to Kotlin!    This was done the _Convert To Kotlin_ machine-translation, and then I went over each line, compared to the Java source, and fixed/updated as necessary.     Some decisions that I made that are definitely open to discussion:   - all code comments + javadocs have been retained, except when the conversion made them irrelevant (e.g. `//fallthrough`, which doesn't exist in `when`s)  - using string templates instead of concat  - created a private inline extension to convert `Byte` to `Char`, since that happens a lot  - I preferred `when` expressions to `if/else`, mostly for readability    I wasn't sure about a few things, so I'll call them out below. Let me know if there's something I've missed!    Oh yeah, fun fact, the Kotlin code is 6% shorter!",2021-12-26 22:05:55,ZacSweers,JvmName,84,4,initial attempt|passing tests|cleanup|Apply suggestions from code review  Co-authored-by: Jake Wharton  github@jakewharton.com>|split `also` to two lines|remove !! and labels|spotless|Apply suggestions from code review  Co-authored-by: Jake Wharton  github@jakewharton.com>|clean up a few more things|pull duplicated code into an inline fun|missed one|refactor double field evaluation to inline fun|spotless|Apply suggestions from code review  Co-authored-by: Jake Wharton  github@jakewharton.com>|var -> val,"following up -- anything you'd else you'd like to see in the PR?|Need to run spotApply|done @JakeWharton|Waiting for #1410 to merge plus a release, then we're good to merge away on kotlin rewrites","|Mostly looks good, but we should take a few review passes.|||||:shipit: |||||||||One actual bug and a bunch of stupid nits. Ready to merge once they're cleared.|||||"
https://github.com/square/moshi/pull/1470,2,Convert ClassJsonAdapter to kotlin,Ref #1252,2022-01-19 05:25:06,ZacSweers,spencergriffin,84,2,Rename ClassJsonAdapter from java to kt|Convert ClassJsonAdapter.java to ClassJsonAdapter.kt|Make kotlin more idiomatic|Spotless|More idiomatic kotlin|Make kotlin more idiomatic|Rename ClassJsonAdapter Factory|Use extension function for throwIfIsCollectionClass|Remove Throws from ClassFactory newInstance because ClassJsonAdapter is now written in kotlin|Use require|Spotless|Fix markdown|Escape package names in markdown|Use for loop|Use buildString to create message prefix|Use require in throwIfIsCollectionClass|Import static Modifier methods to increase readability|Use string template rather than concatenation|Use string template instead of concatenation|Use string template rather than concatenation|Use more descriptive variable name|Extract variable to avoid double negative|Add parameter names to call args|Make ClassJsonAdapter$FieldBinding class final|Use requireNotNull|Make read and write nullable|Exclude the whole ClassJsonAdapter class in japicmp|Add requireNull to Util|Spotless,"Please rebase and fix API conflicts before I proceed with review|#1467, let's get this over the finish line  ","Please take a pass at making the resulting code more idiomatic Kotlin, the auto-converter can do a lot but it's far from perfect and quite obvious in this PR|||||||||||||||||||||||||||"
https://github.com/square/moshi/pull/896,1,Support dynamic defaults constructor invocation in kotlin code gen without kotlin-reflect,"This switches code gen to be able to dynamically invoke constructors and indicate which parameters are not set. No more need for the `copy()` trick! Now full dynamic default values are supported as well.    Caveat: This uses reflection to look up the synthetic defaults constructor that kotlinc generates for these types. Its signature is the original constructor + two extra parameters: one `mask` int parameter that's used to indicate which parameter values are set, and one throwaway `DefaultConstructorMarker` just used to differentiate it. This latter type is also what we use to find this constructor. The reflection is cached, and should be simple to set up with proguard (have pinged proguard folks separately to see if we can just match on that `DefaultConstructorMarker` parameter).    Implementation: There's a new `Util#invokeDefaultConstructor` helper method that accepts a target class, argument values (what the adapter has parsed), and a boolean array of which ones are set. The mask just sets bits that correspond to parameter indices. The boolean array is used to create a mask int, and then the args + mask and `null` throwaway for `DefaultConstructorMarker` are all invoked on the looked up defaults constructor. After eyeballing the [kotlin-reflect implementation](https://github.com/JetBrains/kotlin/blob/deb416484c5128a6f4bc76c39a3d9878b38cec8c/core/reflection.jvm/src/kotlin/reflect/jvm/internal/KCallableImpl.kt#L114-L168), this is fairly similar. It has more mechanics for general use (give it a map of parameter names to values) and figures out the set ones for the mask under the hood, but we know exactly which ones are already set from our parsing already and can just skip that step  .    To give a better sense - for a given `TestClass`:    ```kotlin  data class TestClass(      val required: String,      val optional: String = ""optional"",      val optional2: Int = 2,      val dynamicSelfReferenceOptional: String = required,      val dynamicOptional: Int = createInt(),      val dynamicInlineOptional: Int = createInlineInt()  )    fun createInt(): Int {    return 3  }    inline fun createInlineInt(): Int {    return 3  }  ```    The final bytecode for the constructor we're targeting is roughly this:    ```kotlin  // $FF: synthetic method     public TestClass(String var1, String var2, int var3, String var4, int var5, int var6, int var7, DefaultConstructorMarker var8) {        if ((var7 & 2) != 0) {           var2 = """";        }          if ((var7 & 4) != 0) {           var3 = 2;        }          if ((var7 & 8) != 0) {           var4 = var1;        }          if ((var7 & 16) != 0) {           var5 = TestClassKt.createInt();        }          if ((var7 & 32) != 0) {           int $i$f$createInlineInt = false;           var6 = Random.Default.nextInt();        }          this(var1, var2, var3, var4, var5, var6);     }  ```    Pros:  - Full dynamic default values support, no more functional caveats  - No more double instantiation hacks needed  - No kotlin-reflect needed    Cons:  - Reflection cost, but amortized by the caching and (ideally) whatever I/O process this is running in partnership with.",2019-09-08 21:24:26,ZacSweers,ZacSweers,84,3,"Add Util#invokeDefaultConstructor|Add defaultPrimitiveValue  This will be used to initialize required properties for later invocation of the default constructor|Move isTransient into PropertyGenerator  We will need this in order to know how to invoke constructors even if they have transient parameters|Add notion of hasLocalIsPresentName to PropertyGenerator|Switch to using invokeDefaultConstructor for any default property types|Add code gen versions of default constructor test|Fix mismatched names|Use Arrays.copyOf|Unwrap InvocationTargetException|Use name allocator|Rename createMask to createDefaultValuesParametersMask, use it directly|Opportunistically clean up result variable holder  Only needs to be made if we have non-parameter instances, otherwise we can just return directly|Fix mask name|Remove unnecessary mod|Switch to local lazily-initialized constructor reference  Not working because of some issue in kotlinpoet I don't understand|Fix named usage|Clean up debugging dots|Add proguard/R8 rule for keeping defaults constructor in targets|Make constructor lookup property private|Add another defensive dot|Rework invokeDefaultConstructor to accept vararg args  A little more idiomatic|Update proguard rules","Tempted to just generate sibling classes in bytecode which expose trampolines directly to the synthetic constructor rather than relying on (more) reflection.  That would be neat! I fiddled a bit with generating class files into kapt output via bytebuddy, but I'm not able to actually get existing sources to actually link referencing the class. Something for another time maybe, unless you know a better tool? Maybe it works even without the IDE linking, but didn't get that far in my testing yet|That sounds like a(nother on the long list and ever-growing pile of) kapt bug  |@Egorand do you understand the kotlinpoet issue? It's specifically an issue with the addStatement on AdapterGenerator at line 273. Right now it yields this error, but the error goes away (but obviously becomes a later compilation error) if I remove it [ERROR] [kapt] An exception occurred: java.lang.IllegalStateException: statement enter   followed by statement enter   [ERROR]         at com.squareup.kotlinpoet.CodeWriter.emitCode(CodeWriter.kt:297) [ERROR]         at com.squareup.kotlinpoet.PropertySpec.emit$kotlinpoet(PropertySpec.kt:88) [ERROR]         at com.squareup.kotlinpoet.PropertySpec.emit$kotlinpoet$default(PropertySpec.kt:58) [ERROR]         at com.squareup.kotlinpoet.CodeWriter.emitLiteral(CodeWriter.kt:355) [ERROR]         at com.squareup.kotlinpoet.CodeWriter.emitCode(CodeWriter.kt:223) [ERROR]         at com.squareup.kotlinpoet.CodeWriter.emitCode$default(CodeWriter.kt:216) [ERROR]         at com.squareup.kotlinpoet.FunSpec.emit$kotlinpoet(FunSpec.kt:107) [ERROR]         at com.squareup.kotlinpoet.TypeSpec.emit$kotlinpoet(TypeSpec.kt:267) [ERROR]         at com.squareup.kotlinpoet.TypeSpec.emit$kotlinpoet$default(TypeSpec.kt:88) [ERROR]         at com.squareup.kotlinpoet.FileSpec.emit(FileSpec.kt:160) [ERROR]         at com.squareup.kotlinpoet.FileSpec.writeTo(FileSpec.kt:64) [ERROR]         at com.squareup.kotlinpoet.FileSpec.writeTo(FileSpec.kt:110) [ERROR]         at com.squareup.moshi.kotlin.codegen.JsonClassCodegenProcessor.process(JsonClassCodegenProcessor.kt:91)|Fixed the code gen issue and added a proguard/R8 rule. I think this is ready for merge, @rharter @JakeWharton want to take another pass at the constructor lookup change and proguard rule? Will test the proguard rule separately in a sample app as well. Example generated adapter here: https://gist.github.com/ZacSweers/39771a511a687268f5f2cc947b89f89a Bytecode generation I've experimented a bunch with generating raw bytecode directly (via ASM) that bridges to the synthetic constructor and save the reflection. I've been able to get good progress, but I think build tooling needs work before we could roll it out. Implementation can be found on this branch: https://github.com/square/moshi/tree/z/generateBytecode In short - everything functionally works, but...  On gradle  The generated bridge class does make it into the final jar. I can find it in the debugger and run it reflectively Is partially indexed in the IDE out of the box.  Visible but classpath/dependency errors Fully visible if the output classes directory is added to the project sourcesets, unclear if that's necessary for compilation though   Compilation fails, and class doesn't appear to be part of the compilation classpath itself. Compilation fails on unresolved reference despite linking fine in the IDE. Unclear if this is a bug with gradle, kotlin's gradle plugin, or even how kapt handles generated .class files. Going to ping some folks to try to figure out where to file this. Demo branch on a gradle project: https://github.com/ZacSweers/copydynamic/tree/z/dynamicInvocationTesting   On Maven  The generated bridge class is not indexed in the IDE, even if added to the source sets. Compilation fails on unresolved reference. Have not gotten as far as determining whether it makes it to the final jar.|The preceding wildcard isn't legal in proguard/R8, so we'll have to just keep all the constructors for now. Another thing that occurred to me is that we'd need to keep the kotlin.jvm.internal.DefaultConstructorMarker name or tie it with identifiernamestring in order to match the constructor, but when tried without it, it surprisingly Just Worked  . After going down the rabbit hole I found this in R8, which I think means R8 automatically adds identifiernamestring rules for common reflection APIs like the Class.forName(...) that we use and hence why it worked out of the box. As far as I can tell, this option isn't supported in Proguard though, nor can I find any official documentation anywhere online for identifiernamestring in general other than source code and some dagger comments. So boils down to - do we want to preemptively include this in moshi's proguard file? Or just tell proguard users to manually include it? -keepnames class kotlin.jvm.internal.DefaultConstructorMarker|I'm going to go with including it for now, but can remove later if we decide to recommend manually including it","Tempted to just generate sibling classes in bytecode which expose trampolines directly to the synthetic constructor rather than relying on (more) reflection.||||||Nice!  This'll be a great addition!||||||||Nice work, man!|||||||||||||||||"
https://github.com/square/moshi/pull/435,1,Kotlin Code Gen module,"This is an initial implementation of a code gen module. Originally from https://github.com/hzsweers/CatchUp/tree/master/tooling/moshkt    There's three main components:  * `moshi-kotlin-codegen` - the actually processor implementation  * `integration-test` - An integration test. This contains ignored KotlinJsonAdapter tests (Jesse mentioned wanting them to be able to pass the same tests is the long term goal, so this gives something to chip at) and some basic data classes tests.  * `moshi-kotlin-codegen-runtime` - A runtime artifact with the `@MoshiSerializable` annotation and its corresponding `MoshiSerializableJsonAdapterFactory`. The factory usage is optional, as one could write a factory generator if they wanted to.    Supported:  * Data classes  * `@Json` annotations  * Kotlin language features like nullability and default values (it generates Kotlin code via KotlinPoet, so it can actually leverage these features)  * If a companion object is specified on the source type, it generates an extension `jsonAdapter()` function onto it  * Generics  * Good chunk of Kotshi tests    Unimplemented:  - Support for more than just data classes  - JsonQualifier annotations    For data classes, it's been working swimmingly in CatchUp as well as @rharter's codebases. Code itself could probably use some cleaning up (there's plenty of TODOs left in), but its output seems to be working well so far.    CC @Takhion    Example:    ```kotlin  @MoshiSerializable  data class Foo(     @Json(name = ""first_name"") val firstName: String,     @Json(name = ""last_name"") val lastName: String,     val age: Int,     val nationalities: List String> = emptyList(),     val weight: Float,     val tattoos: Boolean = false,     val race: String?,     val hasChildren: Boolean = false,     val favoriteFood: String? = null,     val favoriteDrink: String? = ""Water""  )  ```    Generates    ```kotlin  package com.squareup.moshi    import kotlin.Any  import kotlin.Boolean  import kotlin.Float  import kotlin.Int  import kotlin.String  import kotlin.collections.List    class Foo_JsonAdapter(moshi: Moshi) : JsonAdapter Foo>() {    private val string_Adapter: JsonAdapter String> = moshi.adapter(String::class.java)      private val int_Adapter: JsonAdapter Int> = moshi.adapter(Int::class.java)      private val list__string_Adapter: JsonAdapter List String>> = moshi.adapter List String>>(Types.newParameterizedType(List::class.java, String::class.java))      private val float_Adapter: JsonAdapter Float> = moshi.adapter(Float::class.java)      private val boolean_Adapter: JsonAdapter Boolean> = moshi.adapter(Boolean::class.java)      override fun fromJson(reader: JsonReader): Foo? {      if (reader.peek() == JsonReader.Token.NULL) {        reader.nextNull Any>()      }      lateinit var firstName: String      lateinit var lastName: String      var age = 0      var nationalities: List String>? = null      var weight = 0.0f      var tattoos: Boolean? = null      var race: String? = null      var hasChildren: Boolean? = null      var favoriteFood: String? = null      var favoriteDrink: String? = null      reader.beginObject()      while (reader.hasNext()) {        when (reader.selectName(OPTIONS)) {          0 -> firstName = string_Adapter.fromJson(reader)!!          1 -> lastName = string_Adapter.fromJson(reader)!!          2 -> age = int_Adapter.fromJson(reader)!!          3 -> nationalities = list__string_Adapter.fromJson(reader)!!          4 -> weight = float_Adapter.fromJson(reader)!!          5 -> tattoos = boolean_Adapter.fromJson(reader)!!          6 -> race = string_Adapter.fromJson(reader)          7 -> hasChildren = boolean_Adapter.fromJson(reader)!!          8 -> favoriteFood = string_Adapter.fromJson(reader)          9 -> favoriteDrink = string_Adapter.fromJson(reader)          -1 -> {            // Unknown name, skip it            reader.nextName()            reader.skipValue()          }        }      }      reader.endObject()      return Foo(firstName = firstName,          lastName = lastName,          age = age,          weight = weight,          race = race).let {            it.copy(nationalities = nationalities ?: it.nationalities,                tattoos = tattoos ?: it.tattoos,                hasChildren = hasChildren ?: it.hasChildren,                favoriteFood = favoriteFood ?: it.favoriteFood,                favoriteDrink = favoriteDrink ?: it.favoriteDrink)          }    }      override fun toJson(writer: JsonWriter, value: Foo?) {      if (value == null) {        writer.nullValue()        return      }      writer.beginObject()      writer.name(""first_name"")      string_Adapter.toJson(writer, value.firstName)      writer.name(""last_name"")      string_Adapter.toJson(writer, value.lastName)      writer.name(""age"")      int_Adapter.toJson(writer, value.age)      writer.name(""nationalities"")      list__string_Adapter.toJson(writer, value.nationalities)      writer.name(""weight"")      float_Adapter.toJson(writer, value.weight)      writer.name(""tattoos"")      boolean_Adapter.toJson(writer, value.tattoos)      if (value.race != null) {        writer.name(""race"")        string_Adapter.toJson(writer, value.race)      }      writer.name(""hasChildren"")      boolean_Adapter.toJson(writer, value.hasChildren)      if (value.favoriteFood != null) {        writer.name(""favoriteFood"")        string_Adapter.toJson(writer, value.favoriteFood)      }      if (value.favoriteDrink != null) {        writer.name(""favoriteDrink"")        string_Adapter.toJson(writer, value.favoriteDrink)      }      writer.endObject()    }      private companion object SelectOptions {      private val OPTIONS: JsonReader.Options by lazy { JsonReader.Options.of(""first_name"", ""last_name"", ""age"", ""nationalities"", ""weight"", ""tattoos"", ""race"", ""hasChildren"", ""favoriteFood"", ""favoriteDrink"") }    }  }  ```",2018-03-12 01:17:55,swankjesse,ZacSweers,84,9,"Add kotlin code gen modules|Update kotlin to 1.2|Add a serializable dummy class|Try using kapt configuration from kotlin-examples repo  Still no luck!|Use proper allocated name for assignment too|Use selectName() API|Clean up constructor parameter annotations & plumbing for qualifiers|Updates poms and kotlin code gen processor to support tests.|Ignore kotlin code gen tests for now  None of these are data classes tests right now, which is the only thing this supports right now|Replace $ with _ in class names for consistency|Shortcut Array types to arrayOf|Add DataClassTest|Try generated option first, fall back to maven after|More idiomatic handling|Only use nonnullable types for adapter properties|Code dump of kotshi tests|Comment out specifics to get compiling|Generics support!|Fix double primitive default|Pick up temporary snapshot for Any fix|Invariance should just be null|Better handling of nullably-bound variance|Just assume the first jvm constructor for now as jvmMethodSig is flaky|Specify types param if needed|Don't do lazy delegation|Clean up nullable typevariablename boundaries|Add type variables to extension function on companion object|Use properties instead of allocated names for more robustness  Since we're already on a snapshot|If there are no type variables, make it null for simpler handling|Fix generics and Type[] handling|Fix unnecessary as casts on primitive defaults|Reference spec directly for possible bangs|Use nullSafe() adapters for anything nullable or with default values|Use object type in makeType()  Types.java cares|Make TestPrimitiveDefaultValues work|Re-enable TestClassWithJavaKeyword|Ignore remaining tests that are pending decisions or JsonQualifier support|Remove customnames test as we're just going to stick with simple @Json|Add toString() implementations|Reenable default values testing, adapt to kotlin lang support|Remove primitive adapters bits since we're not using it|Clean up a bunch of leftover comments|Switch to only nullable handling, report missing properties  This makes all nullable handling for local properties the same, and removes defaults for primitives in the process. It simplifies the handling a lot, and leans on kotlin language features to take care of null handling (null checking and then throwing the lazily evaluated list of missing properties).  One minor change from what kotshi does - this reports the serialized name in the missing properties, not the property name. We could look at supporting this though if we want.|Implement JsonQualifier support|Use Kapt for AutoService/processor declaration|Checkstyle|Remove unused primite type checks|Add test verifying mutable and immutable collections work|Fix test name|Standardize isRequired checks|Add more nullability and mutability tests|Kotlinpoet 0.7.0 final|Switch to new vararg overload for annotation class adapter()|Make suffix just JsonAdapter without underscore|Switch to just a regular constructor for MoshiSerializableFactory|Remove constructor caching|Remove unnecessary framework class checks|Nix unnecessary superclass lookups, inline constructor lookup|Nix null token check in reads|Nix null check in writes, do !! on first value use|Nix null checks in favor of serializeNulls|Inline null checks and fail eagerly|Fix double _Adapter|First pass at simplifying adapter names|Inline names to options property, life into class and rm companion|Differentiate between absent and null, use nullSafe() as needed|Group together compile and test dependencies|Remove incorrect comment|Revert formatting|Set, not mutable set|Collapse else-if nesting to one when|Cleaner formatting test code|Collapse more to locals|Collapse more|Return a nonnullable type in fromJson|Remove redundant out variance|Use KClass where appropriate|End comment in period|Remove redundant comment|Throw on unrecognized type in simplified name|Use illegalargumentexception instead|Emit a nullcheck at the beginning of toJson instead|Remove extra newline|Simplify processing to be less abusive|Skip using asClassName() when possible|Use addComment()|Switch to declared constructors  Technically more correct since we're defining these|Unmodifiable set|return adapter(type, annotationTypes[0])|Slight optimization - check if the type is parameterized first  If the type is a parameterized type, then we know they'll have the two-arg constructor. This way we don't always try and fail the single arg constructor on parameterized types|Add test for type aliases, optimize to reuse adapters if possible  This is a tiny optimization to make type aliases (which did already work) reuse adapter properties if they already exist for the backing type. What this means is that if you have:  typealias Foo = String  and properties foo: Foo bar: String  you'll only get one adapter property field for String, and both will use it|Use string templating where possible|Remove all the kotshi tests","Big ol' update above.  Generics support Lots of various bugfixes Introduction of Kotshi's test code  Questions that need deciding before moving forward: 1 - Should this support kotshi s @JsonDefaultValue pattern? Or to what extent? I m not totally familiar with it, but on the face of it I m not sure it adds anything we can t handle with the current approach 2 - Should this default to/support configurating primitive adapters (nextBoolean() vs .adapter(Boolean::class.java))? 3 - Do we want toString() implementations for adapters? 4 - Kotshi will use @get:JvmName over @field:Json if both are present. I don t think this is idiomatic if we re reading/generating kotlin code though, and should just keep it simple with @Json. Not sure if I m missing context here though 5 - Currently we're using lateinit for expected non-nullable/non-defaultable fields. Wondering if we should just make them all nullable properties and then check the non-nullable/non-defaultable ones at the end to collect a list of all the missing ones. Would line up with something Kotshi appears to do as well 6 - Having to use a kotlinpoet snapshot to pick up the Any? bounds fix, so this can't merge till the next release anyway. Opportunistically picked up the PropertySpec literals support as well|Also this is up for grabs if anyone has any ideas: d4d4926 Talked with @Takhion a bit, but haven't been able to arrive at a good solution yet to match the constructor from kotlin to java. Right now I fell back to just grabbing the first constructor.|haven't been able to arrive at a good solution yet to match the constructor from kotlin to java  Before this PR gets merged I'll release a new version of kotlin-metadata that fixes all edge cases related to that, thanks to the excellent detective work from @hzsweers      |For 1, I would say no. Unless I'm misunderstanding the @JsonDefaultValue duplicates Kotlin default values and is used because those aren't easily exposed in the Java code. IMHO they make the code very messy and verbose, losing some of the benefit of Kotlin.|toString - 36522bc default value handling - Agreed. Talked with Jesse offline too. 881d446 Remove custom names test, per talking with Jesse we'll just go with simple @Json usage - 8126bd1 Decided against configuration for primitive adapters - fb7e514 Just leaves this bit:  5 - Currently we're using lateinit for expected non-nullable/non-defaultable fields. Wondering if we should just make them all nullable properties and then check the non-nullable/non-defaultable ones at the end to collect a list of all the missing ones. Would line up with something Kotshi appears to do as well|About 5, my personal opinion is: absolutely  |Good enough for me! I'll work on that. Was maybe a bit too excited about using local lateinit from kotlin 1.2 :)|They're implemented the same way so it doesn't really matter.|Implemented tracking missing props in 3fd6614 This makes all nullable handling for local properties the same, and removes defaults for primitives in the process. It simplifies the handling a lot, and leans on kotlin language features to take care of null handling (null checking and then throwing the lazily evaluated list of missing properties). One minor change from what kotshi does - this reports the serialized name in the missing properties, not the property name. We could look at supporting this though if we want. It also throws JsonDataException rather than NPEs. Result is a read block looks like this: var string_: String? = null var nullableString: String? = null var integer: Int? = null var nullableInt: Int? = null var isBoolean: Boolean? = null var isNullableBoolean: Boolean? = null var aShort: Short? = null var nullableShort: Short? = null var aByte: Byte? = null var nullableByte: Byte? = null var aChar: Char? = null var nullableChar: Char? = null var list: List String>? = null var nestedList: List Map String, Set String>>>? = null var abstractProperty: String? = null var customName: String? = null var annotated: String? = null var anotherAnnotated: String? = null var genericClass: GenericClass String, List String>>? = null reader.beginObject() while (reader.hasNext()) {     when (reader.selectName(OPTIONS)) {         0 -> string_ = string_Adapter.fromJson(reader)         1 -> nullableString = string_nullable_Adapter.fromJson(reader)         2 -> integer = int_Adapter.fromJson(reader)         3 -> nullableInt = int_nullable_Adapter.fromJson(reader)         4 -> isBoolean = boolean_Adapter.fromJson(reader)         5 -> isNullableBoolean = boolean_nullable_Adapter.fromJson(reader)         6 -> aShort = short_Adapter.fromJson(reader)         7 -> nullableShort = short_nullable_Adapter.fromJson(reader)         8 -> aByte = byte_Adapter.fromJson(reader)         9 -> nullableByte = byte_nullable_Adapter.fromJson(reader)         10 -> aChar = char_Adapter.fromJson(reader)         11 -> nullableChar = char_nullable_Adapter.fromJson(reader)         12 -> list = list__string_Adapter.fromJson(reader)         13 -> nestedList = list__map__string_set__string_Adapter.fromJson(reader)         14 -> abstractProperty = string_Adapter.fromJson(reader)         15 -> customName = string_Adapter.fromJson(reader)         16 -> annotated = string_Adapter.fromJson(reader)         17 -> anotherAnnotated = string_Adapter.fromJson(reader)         18 -> genericClass = genericClass__string_list__string_Adapter.fromJson(reader)         -1 -> {             // Unknown name, skip it             reader.nextName()             reader.skipValue()         }     } } reader.endObject() val missingArguments: () -> JsonDataException = {         NAMES.filterIndexed { index, _ ->             when (index) {                 0 -> string_ == null                 2 -> integer == null                 4 -> isBoolean == null                 6 -> aShort == null                 8 -> aByte == null                 10 -> aChar == null                 12 -> list == null                 13 -> nestedList == null                 14 -> abstractProperty == null                 15 -> customName == null                 16 -> annotated == null                 17 -> anotherAnnotated == null                 18 -> genericClass == null                 else -> false             }         }.let { JsonDataException(""The following required properties were missing: ${it.joinToString()}"") }         } if (string_ == null) {     throw missingArguments() } if (integer == null) {     throw missingArguments() } if (isBoolean == null) {     throw missingArguments() } if (aShort == null) {     throw missingArguments() } if (aByte == null) {     throw missingArguments() } if (aChar == null) {     throw missingArguments() } if (list == null) {     throw missingArguments() } if (nestedList == null) {     throw missingArguments() } if (abstractProperty == null) {     throw missingArguments() } if (customName == null) {     throw missingArguments() } if (annotated == null) {     throw missingArguments() } if (anotherAnnotated == null) {     throw missingArguments() } if (genericClass == null) {     throw missingArguments() } return TestClass(string = string_,         nullableString = nullableString,         integer = integer,         nullableInt = nullableInt,         isBoolean = isBoolean,         isNullableBoolean = isNullableBoolean,         aShort = aShort,         nullableShort = nullableShort,         aByte = aByte,         nullableByte = nullableByte,         aChar = aChar,         nullableChar = nullableChar,         list = list,         nestedList = nestedList,         abstractProperty = abstractProperty,         customName = customName,         annotated = annotated,         anotherAnnotated = anotherAnnotated,         genericClass = genericClass)|Implemented JsonQualifier support in e8427be! I made Types.createJsonQualifierImplementation() public to support it, let me know what you think of that. Resulting code looks like this: private val string_Adapter_for_WrappedInArray_WrappedInObject_Adapter: JsonAdapter String> =             moshi.adapter String>(String::class.java, setOf(Types.createJsonQualifierImplementation(WrappedInArray::class.java), Types.createJsonQualifierImplementation(WrappedInObject::class.java))).nullSafe() Pretty happy with the result - no extra methods, passes the kotshi tests. It does rely on proxies, but I'm not sure there's a way around that right now since kotlin classes don't support subclassing and the only alternative I can think of is to reflectively go yank them out of the constructor params at runtime   . Not sure what the CI failure is, maybe travis goofed? Works for me locally  |Rebased and also switched to using kapt+autoservice for the processor service declaration. I think this is ready for a serious review now, as I think it's feature-complete for data classes in terms of generated code. Missing bits:  Decision on how to handle multiple constructors. Right now it assumes one and picks the first. Supporting a specific one will require an updated kotlin-metadata with improved signature matching|First off, this is awesome. Thank you. Sorry for the slow response; I ve had a few things going on that s prevented me from spending as much time with code as I d prefer. I m going to start by reviewing the generated code. I think that s one of the most interesting. class Simple_JsonAdapter(moshi: Moshi) : JsonAdapter Simple>() {  Accepting a moshi instance in the constructor is clever. Dig. Not sure about the underscore in the generated class name. Is SimpleJsonAdapter okay?     private val string_Adapter_Adapter: JsonAdapter String> =             moshi.adapter(String::class.java).nullSafe()  Why string_Adapter_Adapter and not string_Adapter? Or just stringAdapter ? Why .nullSafe() ? Would it be better to omit .nullSafe() unless the target type is nullable?         if (reader.peek() == JsonReader.Token.NULL) {             reader.nextNull Any>()         }  This shouldn t be necessary. The caller of this adapter can use .nullSafe() on this if they want to permit nulls. The when clause paired with Options is really great. Love that.         val missingArguments: () -> JsonDataException = {                 NAMES.filterIndexed { index, _ ->                     when (index) {                         0 -> prop == null                         else -> false                     }                 }.let { JsonDataException(""The following required properties were missing: ${it.joinToString()}"") }                 }         if (prop == null) {             throw missingArguments()         }  This is nice behavior, but it s so much code. How do you feel about this?         if (prop == null) {             throw JsonDataException(""required property 'prop' missing at ${reader.path}"")         }  You won t get a full list of missing arguments, but I think that s okay.     override fun toJson(writer: JsonWriter, value: Simple?) {         if (value == null) {             writer.nullValue()             return         }  We should assume value is non-null. Callers should use .nullSafe() on this if they may have nulls.      private companion object SelectOptions {         private val NAMES: Array String> = arrayOf(""prop"")          private val OPTIONS: JsonReader.Options = JsonReader.Options.of(*NAMES)     }  Nice use of options. But I think if you can live with not including the full list of missing parameters you can omit the NAMES declaration. Also surprising to have a named companion object. I d prefer just this:     companion object {         private val OPTIONS: JsonReader.Options = JsonReader.Options.of(""prop"")     }  So TL;DR: this is how I d have the generated code look. Mostly the same as what you already have, but generating less code. class SimpleJsonAdapter(moshi: Moshi) : JsonAdapter Simple>() {     private val stringAdapter: JsonAdapter String> =             moshi.adapter(String::class.java)      override fun toString(): String = ""GeneratedJsonAdapter(Simple)""      override fun fromJson(reader: JsonReader): Simple {         var prop: String? = null          reader.beginObject()         while (reader.hasNext()) {             when (reader.selectName(OPTIONS)) {                 0 -> prop = stringAdapter.fromJson(reader)                 -1 -> {                     // Unknown name, skip it                     reader.nextName()                     reader.skipValue()                 }             }         }         reader.endObject()          if (prop == null) {             throw JsonDataException(""required property 'prop' missing at ${reader.path}"")         }          return Simple(prop = prop)     }      override fun toJson(writer: JsonWriter, value: Simple?) {         writer.beginObject()         writer.name(""prop"")         stringAdapter.toJson(writer, value!!.prop)         writer.endObject()     }      companion object {         private val OPTIONS: JsonReader.Options = JsonReader.Options.of(""prop"")     } }|One more idea on the generated code: users will typically have a very small number of instances of each Adapter class: typically 1. I wonder if it s simpler to omit the companion object altogether and declare the options as a normal instance-level val.|From WithCompanionFunction_JsonAdapter:         if (value.v != null) {             writer.name(""v"")             string_nullable_Adapter_Adapter.toJson(writer, value.v)         }  I think the if() check is unnecessary. We can just emit the null ""v"" unconditionally and let Moshi omit it if serializeNulls() is enabled.|From MultipleJsonQualifiers_JsonAdapter:     private val string_Adapter_for_WrappedInArray_WrappedInObject_Adapter: JsonAdapter String> =             moshi.adapter String>(String::class.java, setOf(Types.createJsonQualifierImplementation(WrappedInArray::class.java), Types.createJsonQualifierImplementation(WrappedInObject::class.java))).nullSafe()  I m reluctant to expose the weird Types.createJsonQualifierImplementation method. Instead should we just add an overload of Moshi.adapter() that takes a varargs of annotation types? That might be a lot easier to call.|One more idea for the null checks: the generated code could do this and omit the if (prop == null) checks altogether:         return Simple(                 prop = prop  ?: throw JsonDataException(""required property 'prop' missing at ${reader.path}"")         )|I m reluctant to expose the weird Types.createJsonQualifierImplementation method. Instead should we just add an overload of Moshi.adapter() that takes a varargs of annotation types? That might be a lot easier to call.  Agreed! Much better - 7461d68  I think the if() check is unnecessary. We can just emit the null ""v"" unconditionally and let Moshi omit it if serializeNulls() is enabled.  dea9c0b  I wonder if it s simpler to omit the companion object altogether and declare the options as a normal instance-level val.  Makes sense! 1f08c70  One more idea for the null checks: the generated code could do this and omit the if (prop == null) checks altogether:  Chatted more offline, result is differentiation between absent and null in 428917d  We should assume value is non-null. Callers should use .nullSafe() on this if they may have nulls.  Removed from reads in 90436da  You won t get a full list of missing arguments, but I think that s okay.  Cleaned up and inlined the exceptions thrown into the construction in 8eb5bb4 Also simplified adapter names in d6e8a84 and 4132192|Can you propose the Moshi.adapter API addition in a separate PR?|I can, but any particular reason to? It would presumably just link back to this as an example use case|Yeah I didn't intend for this PR to become this big (wanted to keep it to the processor and iterate on integration tests), but with the offline requests to add both the kotlinjsonadapter tests and kotshi tests, I don't see how it could have stayed small. Have tried to keep the commits small and digestible.|in toJson, there's a check for non-null types: if (value == null) {   throw NullPointerException(""value was null! Wrap in .nullSafe() to write nullable values."") } should there be a symmetric check in fromJson (peek on the reader for null)? In DataClassesTest_DefaultValuesJsonAdapter.kt, I got this: return DataClassesTest.DefaultValues(foo = foo ?: throw JsonDataException(""Required property 'foo' missing at ${reader.path}""))                 .let {                   it.copy(bar = bar ?: it.bar,                       nullableBar = if (nullableBarSet) nullableBar else it.nullableBar,                       bazList = bazList ?: it.bazList)                 } Do we need the copy? In DataClassesTest_DefaultValuesJsonAdapter, the list__stringAdapter property could lose the duplicate underscore.|Trying to unpack the larger comment above and answering inline, let me know if I've messed up the groupings.  in toJson, there's a check for non-null types:  There was, but not anymore after dea9c0b. Also - the code snippet seems to be from fromJson()? I don't think it ever threw exceptions on null values in toJson()  should there be a symmetric check in fromJson (peek on the reader for null)?  This went through a few iterations in the PR, but the most recent one we landed on after @swankjesse's past pass was to read everything into nullable local variables, then throw eagerly in the event of null/absent values for require properties in 8eb5bb4  Do we need the copy?  Yes. Worked on this with @rharter and @swankjesse a fair bit before the PR, it's basically a clever way to ""read"" the default values from the object since we can't really read them at compile time and inline them.  the list__stringAdapter property could lose the duplicate underscore.  I agree! Wasn't sure how to differentiate type params in the simplified names, suggestions welcome :). General trend from the other naming cleanups was to move as close as possible to camel casing and general readability.  it'd still be neat to generate a JsonAdapter.Factory instead of using this class. or was there an explicit reason not to?  (I oddly can't respond to this one inline on github  ) This pattern scales pretty horribly in multi module apps. The idea behind the approach here is to keep the library agnostic with the optional runtime factory for basic drop-in use. Someone else could still write their own factory generator if they want too! Also - assuming you meant to comment on the factory and not the annotation? We definitely need the annotation in some form as a sentinel to the annotation processor.|Think I covered the questions you had. Once #462 is merged, I can make a followup with some cleanups from above and also fro #461","||||||||||||||||||I feel like I've only covered about half. This is a big diff.|||||||||||||||||||||||||||||||||||>any particular reason to [separate the Moshi.adapter change]    It's a new API that affects users outside of this change. Project watchers with use cases or opinions who might not be following this change might be interested in the general changes to Moshi's API. Also, this is a huge PR.  But, no big deal in this case.    I'll take a look a the generated code next week and post thoughts on the code gen stuff!|||||||||||||||||||||||||||||||"
https://github.com/square/moshi/pull/245,1,Fix isPlatformType,"createFieldBindings should not take the allowed platform types into  account.    Uh, so this isn't effectively a problem, and I'm nitpicking my change and improving readability. Figured I'd post here, anyway!    https://github.com/NightlyNexus/moshi/blob/e43252582ab74fe578a15591a683d5e5582d1a40/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java#L83 should not create bindings for private fields of these allowed platform types.  This isn't effectively a problem because the StandardJsonAdapters factory is installed first, and a lot of other things would break before this could ever be a problem.",2017-02-02 14:10:46,swankjesse,NightlyNexus,84,1,Fix isPlatformType  createFieldBindings should not take the allowed platform types into account.,,""
https://github.com/square/moshi/pull/422,2,Fix ClassJsonAdapter to handle ParameterizedTypes.,I broke this in https://github.com/square/moshi/pull/406,2018-02-18 03:56:05,swankjesse,NightlyNexus,84,2,Fix ClassJsonAdapter to handle ParameterizedTypes.,,|
https://github.com/square/moshi/pull/236,1,Add Unwrap JsonAdapter.Factory sample,"Here's a swing to help https://github.com/square/moshi/issues/136  I won't take offense if you have different examples in mind or just don't like these, obviously, haha!",2017-02-02 14:12:06,swankjesse,NightlyNexus,84,3,Add Unwrap JsonAdapter.Factory sample,"oops, just saw the review here. I'll take a look, thank you!|But sample code must be judged most harshly.  Perfect, that's what I selfishly love! I really appreciate it! I will follow up with just the Envelop/Unwrap later tonight. Thanks again!|I think we probably want a mechanism on Moshi where you can specify an annotation using a type literal Enveloped.class and just expand it out to the only reasonable implementation. I can do that, or you can read about dynamic proxies and annotation s hashCode() method if you wanna try it.  I'm going to try to get this going tonight; sounds exciting. Thanks!|I really like where this landed. Thanks for driving API improvements through sample code!|really cool|Yeah! Thanks for the feedback and patience with the changes!","Thanks for getting the ball rolling on this. But sample code must be judged most harshly.    Wanna followup with a single example for the envelope, un-annotated? Then maybe some PRs to make it human for normal people to use annotations in their factories. It shouldn t require users to write loops over the annotations set.||||||||||||||I like where it s going but I still got comments!||||||||||"
https://github.com/square/moshi/pull/1381,10,Implement reflective support for Java Records,"Porting from https://github.com/ZacSweers/MoshiX/tree/main/moshi-records-reflect    This makes a few changes along the way to make the build all happy with how we're doing this:  - Standardizing around Java 8 (which is the minimum supported by gradle toolchains and also soon to be the minimum supported by Kotlin)  - Create a separate Java 16 source set for hosting the actual adapter implementation. This is compiled with Java 16 but is then packaged into the main Moshi jar and denoted as a Multi-Release JAR.  - We gate access to this record adapter at runtime by checking if the requisite record APIs are available.  - We separately have a shim copy of the record adapter in the `main` source set for linking in `BUILT_IN_FACTORIES`, but this is booted out by the real one during packaging.  - Replace animal sniffer with `-release 8`, which functionally accomplishes the same  - Tests are in a dedicated separate `records-test` subproject, making it easier to both write new ones and also ensure our packaging rules for the jar is working correctly (we've had success with this in the past with the codegen artifact's shading being tested in a dedicated tests project)    Resolves #1278    Tests are a little skimpy right now, happy to take suggestions on more we should add! Can also look at fleshing them out more in a followup PR",2021-08-23 16:00:06,ZacSweers,ZacSweers,84,4,"Unwrap InvocationTargetException|Standardize around JDK 8|Update GJF to support newer JDKs|Fix misc java 8 issues in tests|Prepare java 16/records checking at runtime|Implement real RecordJsonAdapter|Spotless|Prepare build for JDK 16+|Fix property name for kapt|Small cleanup|Make FallbackEnum java-8 happy|Remove animalsniffer|Fix format|Add opens for ExtendsPlatformClassWithProtectedFields|Return null every time in shim for main tests|Use JDK 16 + release 8 to replace animalsniffer|Simplify accessor accessible handling|Remove manifest attrs|Fix typo|Fix KCT tests + upgrade it|Cover another|Try explicit kotlin daemon args for java 17?|Disable 17-ea for now until kotlin 1.5.30|Add JsonQualifier and Json(name) tests + fix qualifiers|Ensure constructor is accessible|GJF it properly|GJF 1.11|Use MethodHandle for constructor|Use MethodHandle for accessor too|Revert ""Remove manifest attrs""  This reverts commit 3eb768fd6904bb5c979aa01c3c182e0fb9329d62.|Proper MR jar|*actually* fix GJF, which wasn't getting applied before  We can just enable this everywhere now since we require JDK 16 anyway|Make IDE happy about modules access|Fixup records tests to play nice with modules  Gotta be public|Add complex smoke test|Remove comment  Not a regression test in this case","It looks like animal sniffer ships a shaded old version of ASM and is also no longer being updated since the -release flag covers the same on JDK 9+. Thing is we want to support 8, so we can't use it yet. Seems like we'll need to drop animal sniffer if we want to proceed. Thoughts? Edit I believe we can just use a newer JDK to compile and set an older release flag, will update|Where do you actually pack the MR jar? I don't see any references to META-INF/versions/16/  Yup removed! I misunderstood the requirements for this. This basically just packages it like a simple jar and gates java 16 code on the Util check|No MR jar probably means tools like Graal and D8 (and others) will choke processing the jar. Instead of a gated use and stub you can make the stub return null from a factory method and make the 16 class return a real implementation. Then you unconditionally call the factory and gate behavior on non-null values.|ah good idea. Thanks for bearing with me, learning something new with these MR jars!|Ok think I've got it working now. This is neat!|Being reminded how much the java module system sucks when you have to configure stuff","|||Where do you actually pack the MR jar? I don't see any references to `META-INF/versions/16/`||||||||||||||||||||||||||||||I think I d like to do a follow-up to this to test its internal components, though that shouldn t block release.|||"
https://github.com/square/moshi/pull/917,1,Report json name if different from property name in kotlin,Resolves #800     Want to get feedback on the wording before going and adding tests. This also unifies reflection and code gen's error messaging,2019-10-01 03:04:22,ZacSweers,ZacSweers,84,3,"Report json name in code gen if different from property name  Resolves #800|Unify required property name error message|Report json name in kotlinjsonadapter, match code gen|Upper case JSON  Co-Authored-By: Jake Wharton  jakew@google.com>|Upper case JSON  Co-Authored-By: Jake Wharton  jakew@google.com>|Don't keep constants|Inline json name - property name comparison to util methods|Remove unnecessary constructor keyword|Consolidate non-null/missing property tests to parameterized suite|Add custom json name tests for nonNull property checks|Rename test to make maven happy  Maven won't run the test unless it ends with `Test` or `TestCase`","Most of the tests for this are identical in code gen and reflection, so going to take this opportunity to merge them into a parameterized shared test that checks both against the same code. We can start moving other shared behavior tests into this over time later|Done in 46a7659",||||||||
